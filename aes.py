from cryptography.hazmat.backends import default_backend # default backend refers to the OpenSSL backend to use for cryptographic operations
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes # ciphers, algorithms, and modes are the cryptographic primitives

NONCE = b'0123456789abcdef'  # Nonce is the same size of a block (128 bits for AES), which serves as the initial counter value
# TODO: change the nonce to a random value since it is not supposed to be reused 

def aes_encrypt(key, plaintext):
    # convert key and plaintext to bytes
    key = key.to_bytes(16, byteorder='big')
    plaintext = bytes(plaintext, encoding='utf-8')
    
    # Create a cipher configuration using the key, CTR mode with the nonce
    cipher = Cipher(algorithms.AES(key), modes.CTR(NONCE), backend=default_backend()) # note that the ctr values are incremented by 1 for each block as default

    # Encryption
    encryptor = cipher.encryptor() # Create an encryptor object
    encrypted_data = encryptor.update(plaintext) + encryptor.finalize() # Perform the encryption
    # convert to string
    encrypted_data = encrypted_data.decode("utf-8")
    return encrypted_data


def aes_decrypt(key, encrypted_data):
    # convert key and encrypted_data to bytes
    key = key.to_bytes(16, byteorder='big')
    encrypted_data = bytes(encrypted_data, encoding='utf-8')

    # Create a cipher configuration using the key, CTR mode with the nonce
    cipher = Cipher(algorithms.AES(key), modes.CTR(NONCE), backend=default_backend()) # note that the ctr values are incremented by 1 for each block as default
    
    # Decryption
    decryptor = cipher.decryptor()
    decrypted_data = decryptor.update(encrypted_data) + decryptor.finalize()

    # convert to string
    decrypted_data = decrypted_data.decode("utf-8")
    return decrypted_data
